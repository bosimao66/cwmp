

1、思路一： 单映射
（1）关于映射f
x: 0 1 00 1 0000 000 1111
f:    10 11 20 11 40 30 41 
【f开头的10，代替x中开头的0，意思是1个0）】
【f第二项，11，代替x第二项，1，意思是1个1）】
【f第三项，20，代替x第三项，00，意思是2个0）】
【……】
【f的意思是映射】
y:000 001 010 001 110 100 111
【y的一项000，前两位00，表示1，第三位表示0，
合起来意思是1个0；与f的第一项10对应】

（2）f的反映射-f
x: 010 010 000 000 111 1(不足三个数，保留)
-f: 20 20 10 10 41 
【-f开头的20，代替x中开头的010，把010取前两位当做二进制数，
即01，代表数字2；010最后一位是0，合起来就是两个0，这和20对应】
【-f第二项和-f的第一项类似】
【-f第三项的10，代替x中开头的000，把000取前两位当做二进制数，
即00，代表数字1；000的最后一位是0，合起来就是1个0，这和10对应】
【……】
【-f的意思是f的反映射】
z:00 00 0 0 1111 1(保留的项)

（3）新的方法
显然，z无法通过规则f，变为x，重点在于z的第一项和第二项都是0组成的
所以两项连起来的时候，操作者无法将正确两者分开，所以，需要标志位，
在它们之间插一个“标志位”m
z1:00m00m0m0m1111
【暂时放弃】

2、思路二： 双映射
（1）因式分解
z： 10001 10111 10100 10100
z（十进制表示）： 17 23 20 20
每一个项质因数分解，分给x，y
x 17 23 5 5
y  1 1  4 4
x（二进制表示）10001 10111 00101 00101
y（二进制表示）00001 00001 00100 00100

从z到x、y的过程称之为映射f
那么-f叫做负映射
z拆解成两部分z1和z2，用-f映射得到w
z1：10001 10111
z2：10100 10100
w：17*20 2*20 

发现w可能更长
【暂时放弃】
（2）幂运算
那么更改映射规则，用2的x次方，然后取余数y，
也即z = 2^x + y
z:17 2 20 20  （每5个二进制位，分成子项，那么最大值31，
以2为底的幂指数为最大为4，二进制数位数可为2，但是要注意00b要代表1；
而余数，范围0~(2^5/2 - 1)，二进制位数4，这样看来不太可行）
例子： 17 = 2^4 + 1
z：2^4+1 2^1+0 2^4+
【3】二进制到十进制
x十进制：1234   
十进制数，最多用40个二进制位来表示，0和1交替，或者1做分割符号，0作
排列个数。
1234变为二进制 
y来表示：10011010010，最多的位数，即9999，取2的次幂14，可以覆盖，也就是说
二进制最多要用14个位

   
3、思路三：熵增思想、映射网
一段二进制数，如果有序性高，那么可以找到某种规则去表示；
但是，要考虑到一般情况，是无序的，也就是熵值很大。

（1）可逆操作
例如
f：按位与、或、非、异或
则为可逆操作f；多次的可逆操作，也许可以让无序变得略微有序，
这种有序，可能是针对下面的操作而言的。










